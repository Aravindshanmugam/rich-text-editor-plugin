<!DOCTYPE html>
<html>
  <head>
    <link rel="stylesheet" href="./quill.snow.css" />
    <style>
      html,
      body,
      div,
      span {
        margin: 0;
        padding: 0;
        border: 0;
      }
      #parent-container {
        margin: 0px auto;
      }

      #quill-container {
        height: 350px;
        border: 1px solid #ccc;
      }
      .ql-disabled {
        background-color: #f4f6f6;
      }
      #sizeBar {
        width: 100%;
        background-color: silver;
      }
      #usageBar {
        width: 0%;
        height: 5px;
        padding: 5px 0 0 0;
      }
    </style>
    <!-- DO NOT EDIT THE FOLLOWING LINE-->
    <script src="APPIAN_JS_SDK_URI"></script>
  </head>
  <body>
    <div id="parent-container">
      <div id="quill-container"></div>
      <div id="sizeBar">
        <div id="usageBar"></div>
      </div>
    </div>

    <script src="./quill.min.js"></script>
    <script src="./lz-string.min.js"></script>

    <script>
      const MAX_SIZE_DEFAULT = 10000;
      window.quillMaxSize = MAX_SIZE_DEFAULT;
      window.isQuillActive = false;

      const toolbarOptions = [
        [{ header: [1, 2, 3, 4, 5, 6, false] }, { font: [] }],
        [
          "bold",
          "italic",
          "underline",
          "strike",
          { script: "sub" },
          { script: "super" },
          { color: [] },
          { background: [] }
        ],
        [{ list: "ordered" }, { list: "bullet" }],
        ["link", "image"],
        [{ align: [] }],
        [{ indent: "-1" }, { indent: "+1" }], // outdent/indent
        [{ size: ["small", false, "large", "huge"] }], // custom dropdown
        ["blockquote", "code-block"],
        ["clean"] // clear formatting button
      ];

      var quillContainer = document.getElementById("quill-container");
      var quill = new Quill(quillContainer, {
        modules: {
          toolbar: toolbarOptions
        },
        placeholder: "Start typing...",
        theme: "snow"
      });

      Appian.Component.onNewValue(function(allParameters) {
        var validations = [];
        const maxSize = allParameters.maxSize;
        const isReadOnly = allParameters.readOnly;
        const placeholder = allParameters.placeholder;
        const richText = allParameters.richText;
        const html = allParameters.html;
        const height = allParameters.height;

        var containerHeight;
        switch (height) {
          case "280px":
            containerHeight = "200px";
            break;
          case "490px":
            containerHeight = "410px";
            break;
          case "840px":
            containerHeight = "760px";
            break;
          default:
            containerHeight = "350px";
        }
        quillContainer.style.height = containerHeight;

        /* Update maxSize if specified */
        window.quillMaxSize = maxSize || MAX_SIZE_DEFAULT;

        /* Apply read-only setting */
        if (isReadOnly) {
          quill.enable(false);
          var toolbar = document.querySelector(".ql-toolbar");
          toolbar.style.display = "none";
          var usageBar = document.getElementById("sizeBar");
          usageBar.style.display = "none";
        } else {
          quill.enable(true);
          var toolbar = document.querySelector(".ql-toolbar");
          toolbar.style.display = "block";
          var usageBar = document.getElementById("sizeBar");
          usageBar.style.display = "block";
        }

        /* Set placeholder if specified */
        if (placeholder && !richText && !html) {
          quill.root.dataset.placeholder = placeholder;
        }
        if (!window.isQuillActive) {
          /* Set initial value if specified */
          var cursorRange = quill.getSelection();
          if (richText) {
            try {
              const richTextContents = decompressToJSON(richText);
              if (richTextContents) {
                quill.setContents(richTextContents);
              } else {
                throw "Not compressed rich text value";
              }
            } catch (error) {
              console.warn(
                "Unable to decompress and parse initial value",
                error
              );
              quill.setText(richText);
            }
          } else if (html) {
            const htmlContents = getContentsFromHTML(html);
            quill.setContents(htmlContents);
          }

          /* Updating the contents will reset the cursor, so put it back after updating */
          if (cursorRange) {
            quill.setSelection(cursorRange.index, cursorRange.length, "api");
          }
        } else {
          console.warn("Not updating contents because quill is active");
        }

        /* Check max size */
        const size = getCompressedSize();
        updateUsageBar(size);
        if (size > window.quillMaxSize) {
          validations.push("Content exceeds maximum allowed size");
        }
        Appian.Component.setValidations(validations);
      });

      quill.on("text-change", function(delta, oldDelta, source) {
        if (source == "user") {
          window.isQuillActive = true;
        }
      });

      // https://quilljs.com/docs/api/#events
      function updateValue() {
        const contents = quill.getContents();
        /* Enforce size limit */
        const size = getCompressedSize();
        updateUsageBar(size);
        if (size > window.quillMaxSize) {
          Appian.Component.setValidations(
            "Content exceeds maximum allowed size"
          );
        } else {
          /* Compress and save value */
          if (quill.getText() === "\n") {
            Appian.Component.saveValue("richText", null);
            Appian.Component.saveValue("html", null);
          } else {
            const compressed = compressContents(contents);
            Appian.Component.saveValue("richText", compressed);
            Appian.Component.saveValue("html", getHTMLFromContents(contents));
          }
        }
      }
      // See https://github.com/quilljs/quill/issues/1951#issuecomment-408990849
      quill.root.addEventListener("blur", function(focusEvent) {
        // only update when focus is lost (when relatedTarget == null)
        if (focusEvent && !focusEvent.relatedTarget) {
          window.isQuillActive = false;
          updateValue();
        }
      });

      /************ Utility Methods *************/
      function compressContents(contents) {
        const stringified = JSON.stringify(contents);
        const compressed = LZString.compressToBase64(stringified);
        return compressed;
      }

      function decompressToJSON(compressed) {
        const decompressed = LZString.decompressFromBase64(compressed);
        const richTextContents = JSON.parse(decompressed);
        return richTextContents;
      }

      function getContentsFromHTML(html) {
        var temp = document.createElement("div");
        temp.innerHTML = html;
        var tempQuill = new Quill(temp);
        return tempQuill.getContents();
      }

      function getHTMLFromContents(contents) {
        var tempQuill = new Quill(document.createElement("div"));
        tempQuill.setContents(contents);
        return tempQuill.root.innerHTML;
      }

      function debounce(func, delay) {
        var inDebounce;
        return function() {
          const context = this;
          const args = arguments;
          clearTimeout(inDebounce);
          inDebounce = setTimeout(function() {
            func.apply(context, args);
          }, delay);
        };
      }

      function getCompressedSize() {
        if (quill.getText() === "\n") {
          return 0;
        }
        const contents = quill.getContents();
        const compressed = compressContents(contents);
        return compressed.length;
      }

      function updateUsageBar(size) {
        var usageBar = document.getElementById("usageBar");
        const percentageUsed = (100 * size) / window.quillMaxSize;
        if (percentageUsed <= 100) {
          usageBar.style.width = percentageUsed + "%";
          usageBar.style.backgroundColor = Appian.getAccentColor();
        } else {
          usageBar.style.width = "100%";
          usageBar.style.backgroundColor = "red";
        }
      }
    </script>
  </body>
</html>
